Hello, your task is to **update and complete** the contacts module within an existing Flutter application. Your primary goal is to refactor and enhance the current implementation to strictly follow the **MVVM (Model-View-ViewModel)** architecture and a robust **Offline-First** strategy using the `sqflite` package.

Before creating any new component (class, function, model, or file), you must first analyze the existing codebase to determine if an existing component can be modified or extended. Prioritize code reuse and maintainability.

**Core Architectural Principles:**

* **MVVM:** Ensure a strict separation of concerns between the UI (View), state management/business logic (ViewModel), and the data layer (Model/Repository).
* **Offline-First:** The app must be fully functional without an internet connection. All data reads should come directly from a local `sqflite` database. The repository is responsible for synchronizing the local database with the remote API when a connection is available.
* **Repository Pattern:** The ViewModel must only interact with a `ContactRepository`. This repository will abstract and orchestrate all data flow between the remote data source (API) and the local data source (`sqflite`).
* **Single Source of Truth:** The provided API documentation is the definitive guide for API endpoints and data structures. Ignore any mentions of "GoHighLevel" or "GHL"; the API is the direct backend for this application.

**Coding Standards and Conventions:**

* **One Class Per File:** Strictly adhere to the convention of having only one class per Dart file.
* **Prioritize Refactoring:** Do not create new files, classes, or functions if a similar one already exists. Update and refactor the existing code to meet the requirements. Create new components only when absolutely necessary.
* **Naming Conventions:** Use clear, descriptive, and purposeful names for all files, classes, and functions. **Do not use ambiguous suffixes like "enhanced", "helper", or "new"**. The name should accurately reflect the component's responsibility.

Here are the step-by-step instructions to update the module:

---

### **Step 1: Review and Update the Data Model (Model)**

Locate the existing `Contact` model. If it doesn't exist, create it.

* **Verify Fields:** Ensure the model accurately reflects all necessary fields from the `ghl_contacts` table and API JSON responses (e.g., `ghl_id`, `firstName`, `email`, `companyName`).
* **Implement Local State Fields:** If not already present, add a `sync_status` field (e.g., using an enum `SyncStatus { synced, pending, error }`) and a `last_synced_at` field to manage offline synchronization.
* **Update Serialization:** Check and update the `fromJson()`, `toJson()`, `fromMap()`, and `toMap()` methods to be complete and correct according to the latest model structure.

---

### **Step 2: Refactor the Data Layer (Repository and Data Sources)**

Analyze the existing data layer and refactor it to align with the offline-first repository pattern.

**2.1. API Service (Remote Data Source)**

* Locate the existing API service (e.g., `ContactApiService`).
* Ensure it has methods for every endpoint in the documentation: `getContacts`, `searchContacts`, `getContactDetails`, `createContact`, `updateContact`, and `deleteContact`. Update or add them as necessary.
* Improve error handling for API-specific status codes (4xx, 5xx).

**2.2. Database Service (Local Data Source)**

* Locate the existing database service (e.g., `ContactDatabaseService`).
* Verify its `sqflite` table creation script matches the SQL schema in the documentation.
* Ensure it has robust and efficient local CRUD methods: `insertContact`, `updateContact`, `deleteContact`, `getContact`, and `getAllContacts`.

**2.3. Contact Repository**

* This is the most critical component to review. Locate the `ContactRepository` and ensure it correctly implements the offline-first logic.
* **Fetching Logic (`getContacts`)**: Refactor to *always* return data from the local database. It should attempt an API sync in the background, updating the local DB on success, but the UI should load instantly with local data.
* **Mutation Logic (`createContact`, `updateContact`, `deleteContact`)**: Update these methods to first modify the local database with a `sync_status` of `'pending'`. This will provide immediate UI feedback. Then, attempt to sync the change with the API. On success, update the local status to `'synced'`.

---

### **Step 3: Update the Business Logic (ViewModel)**

Review and refactor the `ContactListViewModel` and `ContactFormViewModel`.

* Ensure they interact **only** with the `ContactRepository`, not directly with the API or Database services.
* Simplify the state management. The ViewModel should expose the state (e.g., `List<Contact>`, `isLoading`) and the View should react to it.
* Remove any business logic from the View and place it inside the appropriate ViewModel.
* Verify that validation logic in the `ContactFormViewModel` matches the requirements in the `CreateGhlContactRequest` and `UpdateGhlContactRequest` sections of the documentation.

---

### **Step 4: Refine the User Interface (View)**

Examine the existing UI widgets (`ContactListView`, `ContactFormView`, etc.).

* Ensure the widgets are stateless where possible and rebuild based on state changes from the ViewModel (using a state management solution like Provider, Riverpod, or BLoC).
* The UI must feel responsive and fast. All user actions (like saving or deleting a contact) should update the UI instantly by reflecting the change in the local database, without waiting for the API response.
* Implement clear UI feedback for different synchronization states (e.g., a subtle icon on contacts that are pending sync).

---

### **Step 5: Verify Dependency Injection and Sync Logic**

* **Dependency Injection:** Check if a service locator like `get_it` is being used correctly to provide dependencies. Ensure all services, repositories, and ViewModels are properly registered and injected.
* **(Optional but Recommended) Synchronization Service:** If a background synchronization mechanism exists, review its logic. It should periodically query for items with a `'pending'` status and try to push them to the API when a network connection is available. If it doesn't exist, consider proposing its implementation as a separate, clearly defined task.